<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="polyfill.css">
  <link rel="stylesheet" href="style.css">
  <script src="https://d3js.org/d3.v7.js"></script>
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <script>
    //This function adds poly fill to the searchbar adapted from https://codepen.io/jpdevries/pen/MoROzK
    function add_polyfill() {
      //Select all inputs which should be polyfilled and apply the things to it
      const lists = document.querySelectorAll('input[data-optgroup-list]');
      lists.forEach((list) => {
        const datalist = document.getElementById(list.getAttribute('data-optgroup-list'));
        const listOptions = document.getElementById("list-options-search");
        let optList = document.createElement("ul");
        listOptions.appendChild(optList);

        //Generate the polyfill list
        for (let optgroup of Array.from(datalist.childNodes)) {
          if (optgroup.nodeName == "#text") {
            continue
          }
          let details = optList.appendChild(document.createElement("li")).appendChild(document.createElement(
            "details"));
          details.setAttribute("open", "true");
          let groupName = document.createElement("summary");
          groupName.textContent = optgroup.getAttribute("label");


          details.appendChild(groupName);
          let optgroupUl = document.createElement("ul");
          for (let option of Array.from(optgroup.childNodes)) {
            if (optgroup.nodeName == "#text") {
              continue
            }
            let optionName = option.getAttribute("value");
            let optionLi = document.createElement("li")
            optionLi.setAttribute("class", "option");
            optionLi.setAttribute("data-value", optionName);

            let optionSpan = document.createElement("span");
            optionSpan.setAttribute("class", "value");
            optionSpan.textContent = optionName;

            optionLi.appendChild(optionSpan);
            optgroupUl.appendChild(optionLi);
          }
          details.appendChild(optgroupUl);
        }

        list.addEventListener('focus', (event) => {
          listOptions.removeAttribute('hidden');
        });


        list.addEventListener('blur', (event) => {
          //listOptions.setAttribute('hidden',"true");
        });

        list.addEventListener('input', (event) => {
          const {
            value
          } = event.target;

          const options = listOptions.querySelectorAll('.option');
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            const optionValue = option.querySelector('.value').innerHTML;

            const show = optionValue.includes(value);
            if (show) {
              option.removeAttribute('hidden');
            } else {
              option.setAttribute('hidden', 'true');
            }

          }

          const details = listOptions.querySelectorAll('details');
          details.forEach((detail) => {
            var allHidden = true;
            const options = detail.querySelectorAll('.option');
            for (let i = 0; i < options.length; i++) {
              const option = options[i];
              if (!option.hasAttribute('hidden')) {
                allHidden = false;
                break;
              }
            }
            if (allHidden) {
              detail.setAttribute('hidden', 'true');
            } else {
              detail.removeAttribute('hidden');
            }
          });

        }); // end input listener


        listOptions.addEventListener('click', (event) => {
          const el = (() => {
            if (!event.target.matches('.option')) { // one of the inner spans is dispatching the event
              return event.target.closest('.option');
            }
            return event.target;
          })();

          list.value = el.dataset.value;
          listOptions.setAttribute('hidden', 'true');
        });



      });
    };
    // Load data into the navigation bar
    const fetches = [
      fetch('../UserOwnedGames.json').then(response => response.json()),
      fetch('../GamesGenre.json').then(response => response.json()),
      fetch('../GenreData.json').then(response => response.json()),
      d3.csv('../RatingData.csv')
    ];

    //Enum like structure to keep track of Page content
    class Page_type {
      static Landing = new Page_type("Landing")
      static Game = new Page_type("Game")
      static Genre = new Page_type("Genre")
      static Group = new Page_type("Group")

      constructor(name) {
        this.name = name;
      }

    }

    var current_page_type = undefined;

    var data = [];
    var update_bar_chart;
    var update_stacked_bar_chart;

    document.addEventListener("DOMContentLoaded", async () => {
      data = await Promise.all(fetches);
      update_bar_chart = create_bar_chart("#svg_bar_chart_users")
      update_stacked_bar_chart = create_stacked_bar_chart("#svg_stacked_bar_chart");
      update_pie_chart_reviews = create_pie_chart("#svg_pie_review")
      update_pie_chart_play_own = create_pie_chart("#svg_pie_play_own")

      load_search_bar();
      update_page_to_landing();
    });

    function getGameTopNPlayTime(Data,reduce_func,topN) {
      return Data.sort((o1,o2) => reduce_func(o2) - reduce_func(o1)).slice(0,topN);
    };

    function load_search_bar() {
      let option_list = d3.select("#search_options_country")
      for (const group of Object.keys(data[0])) {
        option_list.append("option").attr("value", group)
      }
      option_list = d3.select("#search_options_games")
      for (const game of Object.keys(data[1])) {
        option_list.append("option").attr("value", game)
      }
      option_list = d3.select("#search_options_genre")
      for (const genre of Object.keys(data[2])) {
        option_list.append("option").attr("value", genre)
      }

      add_polyfill();
      // set the submit action and prevent page from reloading
      var form = document.getElementById("search_all").addEventListener('submit', (e) => e
        .preventDefault());    
    }

    function update_page_to_landing() {
      current_page_type = Page_type.Landing;
      document.getElementById("g_summary").setAttribute("style", "display:none")
      document.getElementById("page_header").innerText = ""
      let topN = getGameTopNPlayTime(Object.values(data[2]),(d)=> d.user_minutes.reduce(((a,b) => a + b),0), 10)
      update_bar_chart(topN.map((e) => e.user_minutes.reduce(((a,b) => a + b),0)),topN.map((e) => e.genre), "Top 10 Most popular game by playing times", "Total time played in minutes", "Game title")
      document.getElementById("bar_chart_users").setAttribute("style", "display:flex;");
      document.getElementById("stacked_bar_chart").setAttribute("style", "display:inline-flex;");
      document.getElementById("stacked_bar_chart_N").addEventListener("input", (e) => update_stacked_bar_chart(
        wrangle_stacked_bar_chart(Object.values(data[2]),"genre"), Object.keys(data[0]), "Fraction of top N genres per group"));
      createHeatMap("#svg_heat_map");
      document.getElementById("datadiv").setAttribute("style", "display: flex")
      update_stacked_bar_chart(wrangle_stacked_bar_chart(Object.values(data[2]),"genre"), Object.keys(data[0]), "Fraction of top N genres per group");
    }

    function update_page_to_new_group(group) {
      document.getElementById("page_header").innerText = group
      document.getElementById("bar_chart_users").setAttribute("style", "display:block;");
      let topNgroup = getGameTopNPlayTime(Object.values(data[1]),(d)=> d.user_minutes[Object.keys(data[0]).indexOf(group)], 10)
      update_bar_chart(topNgroup.map(d => d.user_minutes[Object.keys(data[0]).indexOf(group)]),topNgroup.map(d => d.name), "Top 10 most popular games for " + group, "Total time played in minutes", "Game title")
      d3.select("#bar_chart_header").html("Playtime for top 10 games of this group");
    }

    function update_page_to_new_game(game) {
      // Reset main
      game_id = data[1][game]['appid']
      link = "https://cdn.akamai.steamstatic.com/steam/apps/" + game_id + "/header.jpg"
      d3.select("#banner").attr('src', link)
      link_desc = "../GamesDescriptions.json"
      var desc = fetch(link_desc, {
          mode: 'cors'
        })
        .then(response => response.json())
        .then(function (result) {
          d3.select("#description").text(result[game_id])
        })
        .catch(error => console.log(error));

      var genres = data[1][game]["tags"]
      d3.select("#tags").selectAll("*").remove()
      var nr_genres = 0
      // d3.select("#tags").append("p")
      genres.forEach((genre) => {
        if (genre != "") {
          nr_genres += 1;
          d3.select("#tags").append("a")
            .attr("class", "app_tag")
            .text(genre)
            .on("click", function () {
              handle_submit(genre)
            })
        }

      })
      if (nr_genres != 0) {
        d3.select("#tags").attr("style", "display:flex")
      } else {
        d3.select("#tags").attr("style", "display:none")

      }

      var price = data[1][game]["price"]
      if (price == null) {
        price = 0
      }
      d3.select("#price").text("Price:  " + price / 100).attr("style", "display:block")
      d3.select("#bar_chart").attr('style', 'display:block')

      update_bar_chart(data[1][game]["user_count"], Object.keys(data[0]), "Number of players in each group", "Users", "Groups", 40, 40);
      update_pie_chart_reviews(prepare_dict(data[1][game], ['positive_reviews', 'negative_reviews']), "Review score")
      var user_cp = prepare_dict(data[1][game], ['user_count', 'user_played'])
      var ar = []
      ar[0] = {
        name: "Own and play",
        value: user_cp[1]["value"]
      }
      ar[1] = {
        name: "Own but never played",
        value: user_cp[0]["value"] - user_cp[1]["value"]
      }

      update_pie_chart_play_own(ar, "Play score")
      d3.select("#page_header").html(game);
      d3.select("#bar_chart_header").html("Number of users per group"); // Maybe add text to actual svg?
      document.getElementById("game_info").setAttribute("style", "display:block");
      document.getElementById("game_image").setAttribute("style", "display:block");      document.getElementById("bar_chart_users").setAttribute("style", "display:block;");
      document.getElementById("pie_chart_rev").setAttribute("style", "display:block;");
      document.getElementById("pie_chart_po").setAttribute("style", "display:block;");
      document.getElementById("game_image").setAttribute("style", "display:block;");
    }

    function prepare_dict(data, keys) {
      var ar = []
      for (const key of keys) {
        const dict = {}
        dict["name"] = key
        var val = data[key]
        if (Array.isArray(val)) {
          val = val.reduce((a, b) => a + b, 0)
        }
        dict["value"] = val
        ar.push(dict)
      }
      return ar
    }

    function update_page_to_new_genre(genre) {
      document.getElementById("page_header").innerText = genre
      document.getElementById("stacked_bar_chart").setAttribute("style", "display:flex;");
      document.getElementById("bar_chart_users").setAttribute("style", "display:block;");
      document.getElementById("pie_chart_rev").setAttribute("style", "display:block;");
      let topNgroup = getGameTopNPlayTime(Object.values(data[1]).filter(d => d.tags.includes(genre)),(d)=>  d.user_minutes.reduce((a, b) => a + b, 0), 10);
      update_bar_chart(topNgroup.map(d => d.user_minutes.reduce((a, b) => a + b, 0)),topNgroup.map(d => d.name), "Top 10 most popular games in " + genre, "Total time played in minutes", "Game titles")
      d3.select("#bar_chart_header").html("Playtime for top 10 games of this genre");
      update_pie_chart_reviews(prepare_dict(data[2][genre], ['positive_total', 'negative_total']), "Review score")
      
      document.getElementById("stacked_bar_chart_N").addEventListener("input", (e) => update_stacked_bar_chart(
        wrangle_stacked_bar_chart(Object.values(data[1]).filter((f) => f.tags.includes(genre)),"name"), Object.keys(data[0]), "Fraction of top N games for " + genre + " per group"));
      update_stacked_bar_chart(wrangle_stacked_bar_chart(Object.values(data[1]).filter((f) => f.tags.includes(genre)),"name"), Object.keys(data[0]), "Fraction of top N games for " + genre + " per group");


    }

    //This function creates setsup the bar chart by providing a update function
    function wrangle_stacked_bar_chart(bar_data,sub_label_field) {
      //Wrangle data
      let N = parseInt(document.getElementById("stacked_bar_chart_N").value)
      let group_top_data = Array(Object.keys(data[0]).length).fill(undefined).map((d,i) => getGameTopNPlayTime(bar_data,(d)=>d.user_minutes[i], N))
      let group_labels = Object.keys(data[0]);
      let group_data = Array(group_labels.length).fill(0).map((e) => [{
        cum_sum: 0
      }]);

      for(let i = 0; i < group_top_data.length; i++){
        for (let j = 0; j < N; j++) {
          group_data[i].push({
            val: group_top_data[i][j].user_minutes[i],
            cum_sum: group_data[i][group_data[i].length - 1].cum_sum + group_top_data[i][j].user_minutes[i],
            label: group_labels[i],
            game: group_top_data[i][j][sub_label_field]
          })
        }
      }
      group_data.map((e) => e.shift())
      group_data.forEach((r, i) => r.forEach((e) => e.total_sum = group_data[i][group_data[i].length - 1].cum_sum))
      return group_data;
    }

    function create_stacked_bar_chart(selector) {
      //Set the viewport and margins

      const viewport_width = 1000;
      const viewport_height = 1000;
      //Set the viewport and margins
      const margin_left = 70;
      const margin_top = 100;


      const svg = d3.select(selector);

      let tooltipNode = document.createElement("div")
      document.querySelector(selector).parentNode.appendChild(tooltipNode)
      let tooltip = d3.select(tooltipNode)
      tooltip
        .style("opacity", 0)
        .attr("id", "stacked-tooltip")
        .style("background-color", "white")
        .style("position", "absolute")
        .style("font-size", "2vh")
        .style("border", "solid")
        .style("border-width", "0.1ch")
        .style("border-radius", "0.5ch");

      var mouseover = function (d) {
        let data = d3.select(d.target).datum();
        var game = data.game;
        var val = data.val;
        tooltip
          .html("Game : <b>" + game + "</b><br>Playtime in hours: <b>" + Math.ceil(val/60)+"</b>")
          .style("opacity", 1)
        d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(0.5)");
      }

      var mousemove = function (d) {
        tooltip 
        .style("transform","translateY(-55%)")  
          .style("left", d.pageX + document.getElementsByTagName('body')[0].clientWidth * 0.01 + "px")
          .style("top", d.pageY + document.getElementsByTagName('body')[0].clientWidth * 0.04 + "px")
      }
      var mouseleave = function (d) {
        tooltip
          .style("opacity", 0)
          d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(1)");
      }

      var mouseClick = function (d) {
        handle_submit(d.target.getAttribute("data-genre"))
        d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(1)");
      }

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width - 2 * margin_left;
      const height = viewport_height - 2 * margin_top;

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', `translate(${margin_left} , ${margin_top})`);
      

      
      //Create axes which fit our box exactly
      const xscale = d3.scaleBand().range([0, width]);
      const yscale = d3.scaleLinear().range([0, height]);

      const xaxis = d3.axisBottom().scale(xscale);
      const g_xaxis = g.append('g').attr('class', 'x axis').style("font-size", "15px");
      const yaxis = d3.axisLeft().scale(yscale).tickFormat(function (d) {
        return d + "%"
      });
      const g_yaxis = g.append('g').attr('class', 'y axis').style("font-size", "20px");

      // X axis label
      g.append("text")
        .attr("transform",
          "translate(" + (width / 2) + " ," +
          (height + margin_top / 1.5) + ")")
        .style("text-anchor", "middle")
        .text("Groups")
        .style("font-size", "25px");


      //Update function to be retured
      function update(new_data, labels, title) {
        // Graph title
        g.select(".title").remove()
        g.append("text")
            .attr("class", "title")
            .attr("x", 0)
            .attr("y", -20)
            .attr("text-anchor", "left")
            .style("font-size", "35px")
            .style("font-family", "arial")
            .text(title)


        xscale.domain(labels).padding(0.1);
        yscale.domain([100, 0]);


        g_xaxis.transition().attr("transform", "translate(0," + height + ")").call(xaxis);
        g_yaxis.transition().call(yaxis);

        posible_subgroups = [].concat.apply([],new_data).map((e) => e.game).filter((v,i,s) => s.indexOf(v) === i)
        let color = d3.scaleOrdinal().domain(posible_subgroups).range(posible_subgroups.map((v,i,s) => d3.color("hsl("+i/s.length*360+",70%,50%)")));
        //Get bars and add bars if require


        let bar_groups = g.selectAll(".bar_group").data(new_data);


        let bar_groups_enter = bar_groups.enter().append("g").attr("class", "bar_group");

        let bars = bar_groups.merge(bar_groups_enter).selectAll("rect").data((d) => d)

        let bar_enter = bars.enter().append("rect")
          .attr('x', (d) => xscale(d.label))
          .attr('y', 0)
          .attr('width', (d) => xscale.bandwidth(d.label))
          .attr('height', 0)
          .attr('class', (d) => 'bar_chart_bar_' + d.game)
          .on("click",mouseClick)
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave);

        //Set the correct values for all the bars

        bars.merge(bar_enter).transition()
          .attr('height', (d) => (height - yscale(d.val / d.total_sum * 100)))
          .attr("y", (d) => yscale(d.cum_sum / d.total_sum * 100))
          .attr('width', (d) => xscale.bandwidth(d.label))
          .attr('fill', (d) => color(d.game))
          .attr('hover-tooltip', (d) => d.game + " : " + d.val)
          .attr('data-genre',(d) => d.game)
          .attr('class', (d) => 'bar_chart_bar_' + d.game.replace(/\W/g, ''))
          .attr('x', (d) => xscale(d.label))

        //Remove unecesary bars
        bars.exit().remove();


      }
      return update
    }

    //This function creates setsup the bar chart by providing a update function
    function create_bar_chart(selector) {
      //Set the viewport and margins
      const viewport_width = 500;
      const viewport_height = 400;
      const margin = {
        top : 60,
        left : 100,
        bottom : 90,
        right : 70
      }


      const svg = d3.select(selector);
      let tooltipNode = document.createElement("div")
      document.querySelector(selector).parentNode.appendChild(tooltipNode)
      let tooltip = d3.select(tooltipNode)
      tooltip
      .style("opacity", 0)
        .attr("id", "stacked-tooltip")
        .style("background-color", "white")
        .style("position", "absolute")
        .style("font-size", "2vh")
        .style("border", "solid")
        .style("border-width", "0.1ch")
        .style("border-radius", "0.5ch");

      var mouseover = function (d) {
        tooltip
          .html("Value : <b>" + d3.select(d.target).datum() + "</b>" )
          .style("opacity", 1)
        d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(0.5)");
      }
      var mousemove = function (d) {
        tooltip
        .style("transform","translateY(-55%)")  
        .style("left", d.pageX + document.getElementsByTagName('body')[0].clientWidth * 0.01 + "px")
        .style("top", d.pageY + document.getElementsByTagName('body')[0].clientWidth * 0.03 + "px")
      }
      var mouseleave = function (d) {
        tooltip
          .style("opacity", 0)
          d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(1)");
      }

      var mouseClick = function (d) {
        handle_submit(d.target.getAttribute("data-label"))
        d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(1)");
      }

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width -  margin.left - margin.right;
      const height = viewport_height - margin.top - margin.bottom;

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left} , ${margin.top})`);


      //Create axes which fit our box exactly
      const xscale = d3.scaleBand().range([0, width]);
      const yscale = d3.scaleLinear().range([0, height]);

      const xaxis = d3.axisBottom().scale(xscale);
      const g_xaxis = g.append('g').attr('class', 'x axis');
      const yaxis = d3.axisLeft().scale(yscale).tickFormat(function (e) {
        if (Math.floor(e) != e) {
          return;
        }
        return e;
      });
      const g_yaxis = g.append('g').attr('class', 'y axis');
      
      // X axis label
      g.append("text")
            .attr("id", "bar_chart_x_label")
            .attr("x", width/2)
            .attr("y", height + margin.top)
            .style("text-anchor", "middle")
            .text("")
            .style("font-size", "12px");  

      // Y axis label
      g.append("text")
        .attr("id", "bar_chart_y_label")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x", 0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("yaxis_t")
        .style("font-size", "12px");
      //Update function to be retured
      function update(new_data, labels, title, yaxis_t, xaxis_t, ylabel_loc=margin.left, xlabel_loc=margin.top) {

        g.select(".title").remove()
        g.append("text")
            .attr("class", "title")
            .attr("x", 0)
            .attr("y", -20)
            .attr("text-anchor", "left")
            .style("font-size", "15px")
            .style("font-family", "arial")
            .text(title)
        
        g.select("#bar_chart_x_label").text(xaxis_t).attr("y", height + xlabel_loc)
        g.select("#bar_chart_y_label").text(yaxis_t).attr("y", 0 - ylabel_loc)
                                                   

        //Create the axis with the new data.
        xscale.domain(labels).padding(0.1);
        yscale.domain([d3.max(new_data), 0]);


        g_xaxis.transition().attr("transform", "translate(0," + height + ")").call(xaxis);
        g_xaxis.selectAll("text").attr("transform", "rotate(25)").style("text-anchor", "start");;
        g_yaxis.transition().call(yaxis);


        //Get bars and add bars if required
        const bars = g.selectAll("rect").data(new_data);

        const bar_enter = bars.enter().append("rect")
          .attr('x', (d) => xscale(labels[new_data.indexOf(d)]))
          .attr('y', height)
          .attr('width', xscale.bandwidth())
          .attr('height', 0)
          .attr('class', (d) => 'bar_chart_bar_' + labels[new_data.indexOf(d)].replace(/\W/g, '')  + " bar_chart_bar")
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave)
          .on("click",mouseClick);

        //Set the correct values for all the bars
        bars.merge(bar_enter).transition()
          .attr('height', (d) => (height - yscale(d)))
          .attr("y", (d) => (yscale(d)))
          .attr('width', xscale.bandwidth())
          .attr('x', (d) => xscale(labels[new_data.indexOf(d)]))
          .attr('class', (d) => 'bar_chart_bar_' + labels[new_data.indexOf(d)].replace(/\W/g, '')  + " bar_chart_bar")
          .attr("data-label", (d) => labels[new_data.indexOf(d)])
        //Remove unecesary bars
        bars.exit().remove();

      }
      return update;
    }

   function create_pie_chart(selector) {

      const viewport_width = 300;
      const viewport_height = 300;

      const margin_left = 30;
      const margin_top = 80;


      const svg = d3.select(selector);

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width - 2*margin_left;
      const height = viewport_height - 2*margin_top;

      //Make the group element which contains the bars
      const g = svg.append('g')
        // .attr('transform', `translate(${margin_left} , ${margin_top})`)
        .attr('transform', 'translate(' + width / 2 + ',' + (height / 2 + margin_top) +')')

      var color = d3.scaleOrdinal(d3.schemeSet3);

      var min = Math.min(width, height);
      var oRadius = min / 2 * 0.9;
      var iRadius = 0;

      // construct default pie
      var pie = d3.pie().value(function (d) {
        return d.value;
      }).sort(null);

      // construct arc generator
      var arc = d3.arc()
        .outerRadius(oRadius)
        .innerRadius(iRadius);


      function update(new_data, title) {
        
        g.select(".title").remove()
        g.append("text")
            .attr("class", "title")
            .attr("y", -margin_top)
            .attr("text-anchor", "middle")
            .style("font-size", "30px")
            .style("font-family", "arial")
            .text(title)

        const pied = pie(new_data)

        color.domain(new_data.map((d) => d.name))

        const old = g.selectAll('path').data();

        function tweenArc(d, i) {
          const interpolate = d3.interpolateObject(old[i], d);
          return (t) => arc(interpolate(t));
        }

        const path = g.selectAll('path').data(pied, (d) => d.data.name).join(
          (enter) => {
            const path_enter = enter.append('path')
            path_enter.append('title')
            return path_enter
          },
          (update) => update,
          (exit) => exit.transition()
          .attrTween('d', tweenArc)
          .remove()
        );

        path.transition()
          .attrTween('d', tweenArc)
          .style('fill', (d) => color(d.data.name))
        path.select('title').text((d) => d.data.name + ':' + d.data.value)

      }
      return update;
    }

    function createHeatMap(selector) {

      const viewport_width = 1000;
      const viewport_height = 900;
      //Set the viewport and margins
      const margin_left = 200;
      const margin_top = 100;
      
      const svg = d3.select(selector)

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width - 2 * margin_left;
      const height = viewport_height - 2 * margin_top;

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', `translate(${margin_left} , ${margin_top})`);

      //Read the data
      ratingData = data[3]
      var myPrice = []
      var myGenres = []
      // Labels of row and columns -> unique identifier of the column called 'price' and 'genre'
      ratingData.forEach((d) => {
        myPrice.push(d.price)
        myGenres.push(d.genre)
      })

      // Build X scales and axis:
      var x = d3.scaleBand()
        .range([0, width])
        .domain(myPrice)
        .padding(0.01);
      g.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x))
        .style("font-size", "20px")


      // X axis label
      g.append("text")
        .attr("transform",
          "translate(" + (width / 2) + " ," +
          (height + margin_top / 2) + ")")
        .style("text-anchor", "middle")
        .text("Price")
        .style("font-size", "25px");

      // Build Y scales and axis:
      var y = d3.scaleBand()
        .range([height, 0])
        .domain(myGenres)
        .padding(0.01);
      g.append("g")
        .call(d3.axisLeft(y))
        .style("font-size", "15px");

      // Y axis label
      g.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin_left)
        .attr("x", 0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Value")
        .style("font-size", "20px");

      // Build color scale
      var myColor = d3.scaleSequential()
        .interpolator(d3.interpolateSpectral)
        .domain([1, 100])

      let tooltipNode = document.createElement("div")
      document.querySelector(selector).parentNode.appendChild(tooltipNode)
      let tooltip = d3.select(tooltipNode)
      tooltip
      .style("opacity", 0)
        .attr("id", "stacked-tooltip")
        .style("background-color", "white")
        .style("position", "absolute")
        .style("font-size", "2vh")
        .style("border", "solid")
        .style("border-width", "0.1ch")
        .style("border-radius", "0.5ch");

      // Three function that change the tooltip when user hover / move / leave a cell
      var mouseover = function (d) {
        tooltip
          .style("opacity", 0.9)
      }
      var mousemove = function (d) {
        let data = d3.select(d.target).datum()
        var pos_reviews = data.pos_reviews
        var count = data.count
        tooltip
          .style("transform","translateY(-55%)")  
          .style("left", d.pageX + document.getElementsByTagName('body')[0].clientWidth * 0.01 + "px")
          .style("top", d.pageY - document.getElementsByTagName('body')[0].clientWidth * 0.02 + "px")
          .html("Positive Reviews: " + ((pos_reviews < 1) ? 'N/A' : "<b>" + pos_reviews + "</b>%") +
            " | Games: <b>" + count + "</b>")
      }

      var mouseleave = function (d) {
        tooltip.style("opacity", 0)
      }

      // add the squares
      g.selectAll()
        .data(ratingData, function (d) {
          return d.price + ':' + d.genre;
        })
        .enter()
        .append("rect")
        .attr("x", function (d) {
          return x(d.price)
        })
        .attr("y", function (d) {
          return y(d.genre)
        })
        .attr("width", x.bandwidth())
        .attr("height", y.bandwidth())
        .style("fill", function (d) {
          return myColor((d.pos_reviews < 1) ? NaN : d.pos_reviews)
        }) //In order for empty entries to be black
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave)

      // Graph title
      g.append("text")
        .attr("x", 0)
        .attr("y", -40)
        .attr("text-anchor", "left")
        .style("font-size", "35px")
        .style("font-family", "arial")
        .text("Positive Reviews");

      // Graph subtitle
      g.append("text")
        .attr("x", 0)
        .attr("y", -15)
        .attr("text-anchor", "left")
        .style("font-size", "25px")
        .style("font-family", "arial")
        .style("fill", "grey")
        .style("max-width", width)
        .text("Percentage of positive reviews based on the game's genre and price");
    }


    function handle_submit(option) {

      if (Object.keys(data[2]).includes(option)) {
        if (current_page_type != Page_type.Genre) {
          cleanup_page();
        }
        document.getElementById("search_all").removeAttribute("error-tooltip");
        update_page_to_new_genre(option);
        current_page_type = Page_type.Genre;
      } else if (Object.keys(data[0]).includes(option)) {
        if (current_page_type != Page_type.Group) {
          cleanup_page();
        }
        document.getElementById("search_all").removeAttribute("error-tooltip");
        update_page_to_new_group(option);
        current_page_type = Page_type.Group;
      } else if (Object.keys(data[1]).includes(option)) {
        if (current_page_type != Page_type.Game) {
          cleanup_page();
        }
        document.getElementById("search_all").removeAttribute("error-tooltip");
        update_page_to_new_game(option);
        current_page_type = Page_type.Game;
      }  else {
        document.getElementById("search_all").setAttribute("error-tooltip",
          "Please only select items fromt the list");
      }
    }

    function cleanup_page() {
      if (current_page_type == Page_type.Landing) {
        document.getElementById("stacked_bar_chart").setAttribute("style", "display:none;");
        d3.select("#svg_heat_map").select("*").remove()
        document.getElementById("datadiv").setAttribute("style", "display: none")
        document.getElementById("g_summary").setAttribute("style", "display:flex")
      } else if (current_page_type == Page_type.Game) {
        document.getElementById("stacked_bar_chart").setAttribute("style", "display:none;");
        document.getElementById("game_info").setAttribute("style", "display:none");
        document.getElementById("game_image").setAttribute("style", "display:none");
        document.getElementById("bar_chart_users").setAttribute("style", "display:none;");
        document.getElementById("pie_chart_rev").setAttribute("style", "display:none;");
        document.getElementById("pie_chart_po").setAttribute("style", "display:none;");
      } else if (current_page_type == Page_type.Genre) {
        document.getElementById("stacked_bar_chart").setAttribute("style", "display:none;");
        document.getElementById("bar_chart_users").setAttribute("style", "display:none;");
        document.getElementById("stacked_bar_chart").setAttribute("style", "display:none;");
        document.getElementById("pie_chart_rev").setAttribute("style", "display:none;");
      } else if (current_page_type == Page_type.Group) {
        document.getElementById("stacked_bar_chart").setAttribute("style", "display:none;");
        document.getElementById("bar_chart_users").setAttribute("style", "display:none;");
      }

    }
  </script>
</head>

<body style="background-color:#c7d5e0">
  <div class="wrap">
    <div id="home_box" style="margin-left:9%;margin-right: 9%; width: 7%;align-items: center;display:flex;">
      <button id="homeButton" onclick="cleanup_page();update_page_to_landing()">
      <i class="fa fa-home" style="color: white; font-size: 6vh;"></i>
    </button>
    </div>
    <form class="search_all" id="search_all" onsubmit='handle_submit(document.getElementById("input_field").value)'>
      <input data-optgroup-list="search_options" class="searchTerm" id="input_field" type="select"></input>
      <datalist id="search_options">
        <optgroup id="search_options_genre" label="Genre"></optgroup>
        <optgroup id="search_options_country" label="Group"></optgroup>
        <optgroup id="search_options_games" label="Games"></optgroup>
      </datalist>
      <div class="list-options" id="list-options-search" hidden>
      </div>
      <!-- <input type="text" class="searchTerm" placeholder="What are you looking for?"> -->
      <button type="submit" class="searchButton" id=searchButton onclick="handle_submit()" height="100%">
        <svg id="svg_button" class="search-icon" viewBox="0 0 24 24">
          <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
          <path d="M0 0h24v24H0z" fill="none"/>
      </svg>
      </button>
    </form>
  </div>
  <div class="main" id="main">
    <div id="g_summary">
      <div id="game_image" style="display: none;"><img id="banner"></div>
      <div id="game-text">
        <h1 id="page_header"></h1>
        <div id="game_info">
          <p id="description" class="description_text"></p>
          <div id="tags" class="description_text", style= "display:none">Genres:   </div>
          <h3 id="price" class="description_text", style= "display:none">Price: </h3>
        </div>
      </div>
      <div id="pie_chart_rev">
        <svg id="svg_pie_review" class="pie_chart review"></svg>
      </div>
      <div id="pie_chart_po">
        <svg id="svg_pie_play_own" class="pie_chart p_own"></svg>
      </div>
    </div>
    <div class="charts">
        <div id="stacked_bar_chart">
            <input type="number" min="1" max="10" value="5" id="stacked_bar_chart_N">  
          <svg id="svg_stacked_bar_chart"></svg>
        </div>
        <div id="bar_chart_users" style="display: none;" >
          <!-- <h3 id="bar_chart_header">Number of user per group</h3> -->
          <svg id="svg_bar_chart_users" class="bar_chart bar_playing_time" class="svg_graph"></svg>
        </div>
        <div id="datadiv">
          <svg id="svg_heat_map" class="svg_graph"></svg>
        </div>
    </div>
  </div>
</body>

</html>