<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="polyfill.css">
  <script src="https://d3js.org/d3.v7.js"></script>
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <script>
    //This function adds poly fill to the searchbar adapted from https://codepen.io/jpdevries/pen/MoROzK
    function add_polyfill() {
      //Select all inputs which should be polyfilled and apply the things to it
      const lists = document.querySelectorAll('input[data-optgroup-list]');
      lists.forEach((list) => {
        const datalist = document.getElementById(list.getAttribute('data-optgroup-list'));
        const listOptions = document.getElementById("list-options-search");
        let optList = document.createElement("ul");
        listOptions.appendChild(optList);
        
        //Generate the polyfill list
        for(let optgroup of Array.from(datalist.childNodes)){
          if(optgroup.nodeName == "#text"){continue}
          let details = optList.appendChild(document.createElement("li")).appendChild(document.createElement("details"));
          details.setAttribute("open","true");
          let groupName = document.createElement("summary");
          groupName.textContent = optgroup.getAttribute("label");
          

          details.appendChild(groupName);
          let optgroupUl = document.createElement("ul");
          for(let option of Array.from(optgroup.childNodes) ){
            if(optgroup.nodeName == "#text"){continue}
            let optionName = option.getAttribute("value");
            let optionLi = document.createElement("li")
            optionLi.setAttribute("class", "option");
            optionLi.setAttribute("data-value", optionName);
            
            let optionSpan = document.createElement("span");
            optionSpan.setAttribute("class","value");
            optionSpan.textContent = optionName;

            optionLi.appendChild(optionSpan);
            optgroupUl.appendChild(optionLi);
          }
          details.appendChild(optgroupUl);
        }

        list.addEventListener('focus', (event) => {
          listOptions.removeAttribute('hidden');
        });


        list.addEventListener('blur', (event) => {
          //listOptions.setAttribute('hidden',"true");
        });

        list.addEventListener('input', (event) => {
          const {
            value
          } = event.target;

          const options = listOptions.querySelectorAll('.option');
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            const optionValue = option.querySelector('.value').innerHTML;

            const show = optionValue.includes(value);
            if (show) {
              option.removeAttribute('hidden');
            } else {
              option.setAttribute('hidden', 'true');
            }

          }

          const details = listOptions.querySelectorAll('details');
          details.forEach((detail) => {
            var allHidden = true;
            const options = detail.querySelectorAll('.option');
            for (let i = 0; i < options.length; i++) {
              const option = options[i];
              if (!option.hasAttribute('hidden')) {
                allHidden = false;
                break;
              }
            }
            if (allHidden) {
              detail.setAttribute('hidden', 'true');
            } else {
              detail.removeAttribute('hidden');
            }
          });

        }); // end input listener


        listOptions.addEventListener('click', (event) => {
          const el = (() => {
            if (!event.target.matches('.option')) { // one of the inner spans is dispatching the event
              return event.target.closest('.option');
            }
            return event.target;
          })();

          list.value = el.dataset.value;
          listOptions.setAttribute('hidden', 'true');
        });



      });
    };
    // Load data into the navigation bar
    const fetches = [
      fetch('../UserOwnedGames.json').then(response => response.json()),
      fetch('../GamesGenre.json').then(response => response.json()),
      fetch('../GenreData.json').then(response => response.json())
    ];


    data = [];
    groups = [];

    document.addEventListener("DOMContentLoaded", async () => {
      data = await Promise.all(fetches);
      groups = Object.keys(data[0])
      update_bar_chart = create_bar_chart("#svg_bar_chart")
      load_search_bar();
    });

    function load_search_bar() {
      let option_list = d3.select("#search_options_country")
      for (const group of Object.keys(data[0])) {
        option_list.append("option").attr("value", group)
      }
      option_list = d3.select("#search_options_games")
      for (const game of Object.keys(data[1])) {
        option_list.append("option").attr("value", game)
      }
      option_list = d3.select("#search_options_genre")
      for (const genre of Object.keys(data[2])) {
        option_list.append("option").attr("value", genre)
      }

      add_polyfill();
      // set the submit action and prevent page from reloading
      d3.select("#input_all").attr("onsubmit", "handle_submit()");
      var form = document.getElementById("input_all").addEventListener('submit', (e) => e
        .preventDefault());
    }

    function update_page_to_new_group(group) {}

    function update_page_to_new_game(game) {
      // Reset main
      game_id = data[1][game]['appid']
      link = "https://cdn.akamai.steamstatic.com/steam/apps/" + game_id + "/header.jpg"
      document.getElementById("banner").setAttribute('src', link)

      link_desc = "../GamesDescriptions.json"

      var desc = fetch(link_desc, {
          mode: 'cors'
        })
        .then(response => response.json())
        .then(function (result) {
          document.getElementById("description").innerText = result[game_id]
        })
        .catch(error => console.log(error));
      document.getElementById("bar_chart").setAttribute('style', 'diplay:block')
      update_bar_chart(data[1][game]["user_count"]);
      d3.select("#page_header").html(game);
    }

    function update_page_to_new_genre() {}

    //This function creates setsup the bar chart by providing a update function
    function create_bar_chart(selector) {
      //Set the viewport and margins
      const viewport_width = 300;
      const viewport_height = 200;

      const margin_left = 30;
      const margin_top = 30;


      const svg = d3.select(selector);

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width - 2 * margin_left;
      const height = viewport_height - 2 * margin_top;

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', `translate(${margin_left} , ${margin_top})`);


      //Create axes which fit our box exactly
      const xscale = d3.scaleBand().range([0, width]);
      const yscale = d3.scaleLinear().range([0, height]);

      const xaxis = d3.axisBottom().scale(xscale);
      const g_xaxis = g.append('g').attr('class', 'x axis');
      const yaxis = d3.axisLeft().scale(yscale).tickFormat(function (e) {
        if (Math.floor(e) != e) {
          return;
        }

        return e;
      });
      const g_yaxis = g.append('g').attr('class', 'y axis');

      //Update function to be retured
      function update(new_data) {

        //Create the axis with the new data.
        xscale.domain(groups).padding(0.1);
        yscale.domain([d3.max(new_data), 0]);


        g_xaxis.transition().attr("transform", "translate(0," + height + ")").call(xaxis);
        g_yaxis.transition().call(yaxis);


        //Get bars and add bars if required
        const bars = g.selectAll("rect").data(new_data);

        const bar_enter = bars.enter().append("rect")
          .attr('x', (d) => xscale(groups[new_data.indexOf(d)]))
          .attr('y', height)
          .attr('width', xscale.bandwidth())
          .attr('height', 0);

        //Set the correct values for all the bars
        bars.merge(bar_enter).transition()
          .attr('height', (d) => (height - yscale(d)))
          .attr("y", (d) => (yscale(d)))
          .attr('width', xscale.bandwidth())
          .attr('x', (d) => xscale(groups[new_data.indexOf(d)]))

        //Remove unecesary bars
        bars.exit().remove();

      }
      return update;
    }


    function createPieChart(svgSelector, stateAttr, colorScheme) {
      const margin = 10;
      const radius = 100;

      // Creates sources <svg> element
      const svg = d3.select(svgSelector)
        .attr('width', radius * 2 + margin * 2)
        .attr('height', radius * 2 + margin * 2);

      // Group used to enforce margin
      const g = svg.append('g')
        .attr('transform', `translate(${radius + margin},${radius + margin})`);

      const pie = d3.pie().value((d) => d.values.length).sortValues(null).sort(null);
      const arc = d3.arc().outerRadius(radius).innerRadius(0);
      const noSlice = [{
          startAngle: 0,
          endAngle: Math.PI * 2,
          padAngle: 0
        },
        {
          startAngle: 0,
          endAngle: 0,
          padAngle: 0
        }
      ];

      const cscale = d3.scaleOrdinal(colorScheme);

      function update(new_data) { //{key: string, values: IPerson[]}[]
        const pied = pie(new_data);
        // Render the chart with new data

        cscale.domain(new_data.map((d) => d.key));

        // DATA JOIN
        const old = g.selectAll('path').data();

        function tweenArc(d, i) {
          const interpolate = d3.interpolateObject(old[i], d);
          return (t) => arc(interpolate(t));
        }

        // DATA JOIN
        const path = g.selectAll('path').data(pied, (d) => d.data.key).join(
          // ENTER
          // new elements
          (enter) => {
            const path_enter = enter.append('path')
              .attr('d', (d, i) => arc(noSlice[i]))
              .on('click', (event, d) => {
                if (state[stateAttr] === d.data.key) {
                  state[stateAttr] = null;
                } else {
                  state[stateAttr] = d.data.key;
                }
                updateApp();
              });
            path_enter.append('title');
            return path_enter;
          },
          (update) => update,
          (exit) => exit.transition()
          .attrTween('d', tweenArc)
          .remove()
        );

        // ENTER + UPDATE
        // both old and new elements
        path
          .classed('selected', (d) => d.data.key === state.selectedSex)
          .transition()
          .attrTween('d', tweenArc)
          .style('fill', (d) => cscale(d.data.key));

        path.select('title').text((d) => `${d.data.key}: ${d.data.values.length}`);
      }
      return update;
    }

    function handle_submit() {
      let option = document.getElementById("input_field").value
      if (Object.keys(data[0]).includes(option)) {
        document.getElementById("input_all").removeAttribute("error-tooltip");
        update_page_to_new_group()

      }
      if (Object.keys(data[1]).includes(option)) {
        document.getElementById("input_all").removeAttribute("error-tooltip");
        update_page_to_new_game(option);
      }
      if (Object.keys(data[2]).includes(option)) {
        document.getElementById("input_all").removeAttribute("error-tooltip");
        update_page_to_new_genre()
      } else {
        document.getElementById("input_all").setAttribute("error-tooltip",
          "Please only select items fromt the list")
      }
    }
  </script>
</head>

<body>
  <form id="input_all">
    <input data-optgroup-list="search_options" id="input_field" type="select"></input>
    <datalist id="search_options">
      <optgroup id="search_options_genre" label="Genre"></optgroup>
      <optgroup id="search_options_country" label="Group"></optgroup>
      <optgroup id="search_options_games" label="Games"></optgroup>
    </datalist>
    <div class="list-options" id="list-options-search" hidden>
    </div>
    <input type="submit" value="Go">
  </form>

  <div id="main">
    <h1 id="page_header"></h1>
    <img id="banner">
    <p id="description"></p>

  </div>
  <section id="pie_chart" style="display: none;">
    <h3>Distribution actually playing</h3>
    <svg id="svg_pie" class="pie_chart_own_play"></svg>
  </section>
  <div id="bar_chart" style="display: none;"><svg id="svg_bar_chart" class="bar_chart bar_playing_time"></svg></div>
</body>

</html>