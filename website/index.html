<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="polyfill.css">
  <script src="https://d3js.org/d3.v7.js"></script>
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <script>
    //This function adds poly fill to the searchbar adapted from https://codepen.io/jpdevries/pen/MoROzK
    function add_polyfill() {
      //Select all inputs which should be polyfilled and apply the things to it
      const lists = document.querySelectorAll('input[data-optgroup-list]');
      lists.forEach((list) => {
        const datalist = document.getElementById(list.getAttribute('data-optgroup-list'));
        const listOptions = document.getElementById("list-options-search");
        let optList = document.createElement("ul");
        listOptions.appendChild(optList);

        //Generate the polyfill list
        for (let optgroup of Array.from(datalist.childNodes)) {
          if (optgroup.nodeName == "#text") {
            continue
          }
          let details = optList.appendChild(document.createElement("li")).appendChild(document.createElement(
            "details"));
          details.setAttribute("open", "true");
          let groupName = document.createElement("summary");
          groupName.textContent = optgroup.getAttribute("label");


          details.appendChild(groupName);
          let optgroupUl = document.createElement("ul");
          for (let option of Array.from(optgroup.childNodes)) {
            if (optgroup.nodeName == "#text") {
              continue
            }
            let optionName = option.getAttribute("value");
            let optionLi = document.createElement("li")
            optionLi.setAttribute("class", "option");
            optionLi.setAttribute("data-value", optionName);

            let optionSpan = document.createElement("span");
            optionSpan.setAttribute("class", "value");
            optionSpan.textContent = optionName;

            optionLi.appendChild(optionSpan);
            optgroupUl.appendChild(optionLi);
          }
          details.appendChild(optgroupUl);
        }

        list.addEventListener('focus', (event) => {
          listOptions.removeAttribute('hidden');
        });


        list.addEventListener('blur', (event) => {
          //listOptions.setAttribute('hidden',"true");
        });

        list.addEventListener('input', (event) => {
          const {
            value
          } = event.target;

          const options = listOptions.querySelectorAll('.option');
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            const optionValue = option.querySelector('.value').innerHTML;

            const show = optionValue.includes(value);
            if (show) {
              option.removeAttribute('hidden');
            } else {
              option.setAttribute('hidden', 'true');
            }

          }

          const details = listOptions.querySelectorAll('details');
          details.forEach((detail) => {
            var allHidden = true;
            const options = detail.querySelectorAll('.option');
            for (let i = 0; i < options.length; i++) {
              const option = options[i];
              if (!option.hasAttribute('hidden')) {
                allHidden = false;
                break;
              }
            }
            if (allHidden) {
              detail.setAttribute('hidden', 'true');
            } else {
              detail.removeAttribute('hidden');
            }
          });

        }); // end input listener


        listOptions.addEventListener('click', (event) => {
          const el = (() => {
            if (!event.target.matches('.option')) { // one of the inner spans is dispatching the event
              return event.target.closest('.option');
            }
            return event.target;
          })();

          list.value = el.dataset.value;
          listOptions.setAttribute('hidden', 'true');
        });



      });
    };
    // Load json data
    const fetches = [
      fetch('../UserOwnedGames.json').then(response => response.json()),
      fetch('../GamesGenre.json').then(response => response.json()),
      fetch('../GenreData.json').then(response => response.json())
    ];

    //Enum like structure to keep track of Page content
    class Page_type {
      static Landing = new Page_type("Landing")
      static Game = new Page_type("Game")
      static Genre = new Page_type("Genre")
      static Group = new Page_type("Group")

      constructor(name) {
        this.name = name;
      }

    }

    var current_page_type = undefined;

    var data = [];
    var update_bar_chart;
    var update_stacked_bar_chart;


    document.addEventListener("DOMContentLoaded", async () => {
      data = await Promise.all(fetches);
      update_bar_chart = create_bar_chart("#svg_bar_chart_users");
      update_stacked_bar_chart = create_stacked_bar_chart("#svg_stacked_bar_chart");
      load_search_bar();

      update_page_to_landing();
    });

    function getGameTopNPlayTime(Data,reduce_func,topN) {
      return Data.sort((o1,o2) => reduce_func(o2) - reduce_func(o1)).slice(0,topN);
    };

    function load_search_bar() {
      let option_list = d3.select("#search_options_country")
      for (const group of Object.keys(data[0])) {
        option_list.append("option").attr("value", group)
      }
      option_list = d3.select("#search_options_games")
      for (const game of Object.keys(data[1])) {
        option_list.append("option").attr("value", game)
      }
      option_list = d3.select("#search_options_genre")
      for (const genre of Object.keys(data[2])) {
        option_list.append("option").attr("value", genre)
      }

      add_polyfill();
      // set the submit action and prevent page from reloading
      var form = document.getElementById("input_all").addEventListener('submit', (e) => e
        .preventDefault());
    }

    function update_page_to_landing() {
      current_page_type = Page_type.Landing;
      document.getElementById("bar_chart_users").setAttribute("style", "display:block;");
      let topN = getGameTopNPlayTime(Object.values(data[2]),(d)=> d.user_minutes.reduce(((a,b) => a + b),0), 10)
      update_bar_chart(topN.map((e) => e.user_minutes.reduce(((a,b) => a + b),0)),topN.map((e) => e.genre))

      document.getElementById("stacked_bar_chart").setAttribute("style", "display:block;");
      document.getElementById("stacked_bar_chart_N").addEventListener("input", (e) => update_stacked_bar_chart(
        wrangle_stacked_bar_chart(Object.values(data[2]),"genre"), Object.keys(data[0])));
      update_stacked_bar_chart(wrangle_stacked_bar_chart(Object.values(data[2]),"genre"), Object.keys(data[0]));
    }

    function update_page_to_new_group(group) {
      document.getElementById("bar_chart_users").setAttribute("style", "display:block;");
      let topNgroup = getGameTopNPlayTime(Object.values(data[1]),(d)=> d.user_minutes[Object.keys(data[0]).indexOf(group)], 10)
      update_bar_chart(topNgroup.map(d => d.user_minutes[Object.keys(data[0]).indexOf(group)]),topNgroup.map(d => d.name))
      d3.select("#bar_chart_header").html("Playtime for top 10 games of this group");
    }

    function update_page_to_new_game(game) {
      // Reset main
      game_id = data[1][game]['appid']
      link = "https://cdn.akamai.steamstatic.com/steam/apps/" + game_id + "/header.jpg"
      document.getElementById("banner").setAttribute('src', link)

      link_desc = "../GamesDescriptions.json"

      var desc = fetch(link_desc, {
          mode: 'cors'
        })
        .then(response => response.json())
        .then(function (result) {
          document.getElementById("description").innerText = result[game_id]
        })
        .catch(error => console.log(error));
      document.getElementById("bar_chart_users").setAttribute('style', 'diplay:block')
      update_bar_chart(data[1][game]["user_count"], Object.keys(data[0]));
      d3.select("#page_header").html(game);
      d3.select("#bar_chart_header").html("Number of users per group");
    }

    function update_page_to_new_genre(genre) {
      document.getElementById("stacked_bar_chart").setAttribute("style", "display:block;");
      document.getElementById("bar_chart_users").setAttribute("style", "display:block;");
      let topNgroup = getGameTopNPlayTime(Object.values(data[1]).filter(d => d.tags.includes(genre)),(d)=>  d.user_minutes.reduce((a, b) => a + b, 0), 10);
      update_bar_chart(topNgroup.map(d => d.user_minutes.reduce((a, b) => a + b, 0)),topNgroup.map(d => d.name))
      d3.select("#bar_chart_header").html("Playtime for top 10 games of this genre");

      document.getElementById("stacked_bar_chart_N").addEventListener("input", (e) => update_stacked_bar_chart(
        wrangle_stacked_bar_chart(Object.values(data[1]).filter((f) => f.tags.includes(genre)),"name"), Object.keys(data[0])));
      update_stacked_bar_chart(wrangle_stacked_bar_chart(Object.values(data[1]).filter((f) => f.tags.includes(genre)),"name"), Object.keys(data[0]));


    }

    function wrangle_stacked_bar_chart(bar_data,sub_label_field) {
      //Wrangle data
      let N = parseInt(document.getElementById("stacked_bar_chart_N").value)
      let group_top_data = Array(Object.keys(data[0]).length).fill(undefined).map((d,i) => getGameTopNPlayTime(bar_data,(d)=>d.user_minutes[i], N))
      let group_labels = Object.keys(data[0]);
      let group_data = Array(group_labels.length).fill(0).map((e) => [{
        cum_sum: 0
      }]);

      for(let i = 0; i < group_top_data.length; i++){
        for (let j = 0; j < N; j++) {
          group_data[i].push({
            val: group_top_data[i][j].user_minutes[i],
            cum_sum: group_data[i][group_data[i].length - 1].cum_sum + group_top_data[i][j].user_minutes[i],
            label: group_labels[i],
            game: group_top_data[i][j][sub_label_field]
          })
        }
      }
      group_data.map((e) => e.shift())
      group_data.forEach((r, i) => r.forEach((e) => e.total_sum = group_data[i][group_data[i].length - 1].cum_sum))
      return group_data;
    }

    function create_stacked_bar_chart(selector) {
      //Set the viewport and margins
      const viewport_width = 300;
      const viewport_height = 200;

      const margin_left = 40;
      const margin_top = 30;


      const svg = d3.select(selector);

      let tooltipNode = document.createElement("div")

      document.querySelector(selector).parentNode.appendChild(tooltipNode)
      let tooltip = d3.select(tooltipNode)
      tooltip
        .style("opacity", 0)
        .attr("id", "stacked-tooltip")
        .style("background-color", "white")
        .style("postion","absolute")
        .style("border-radius", "5px")
        .style("border", "2px")
        .style("border-color","black")

      var mouseover = function (d) {
        let data = d3.select(d.target).datum();
        var game = data.game;
        var val = data.val;
        tooltip
          .html("Game : " + game + "<br>Playtime in minutes: " + val)
          .style("opacity", 1)
        d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(0.5)");
      }
      var mousemove = function (d) {
        tooltip
        
        .style("transform","translateY(-55%)")  
          .style("left", d.pageX  +"px")
          .style("top", d.pageY - 20 + "px")
      }
      var mouseleave = function (d) {
        tooltip
          .style("opacity", 0)
          d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(1)");
      }

      var mouseClick = function (d) {
        cleanup_page();
        handle_submit(d.target.getAttribute("data-genre"))
        d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(1)");
      }

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width - 2 * margin_left;
      const height = viewport_height - 2 * margin_top;

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', `translate(${margin_left} , ${margin_top})`);


      //Create axes which fit our box exactly
      const xscale = d3.scaleBand().range([0, width]);
      const yscale = d3.scaleLinear().range([0, height]);

      const xaxis = d3.axisBottom().scale(xscale);
      const g_xaxis = g.append('g').attr('class', 'x axis');
      const yaxis = d3.axisLeft().scale(yscale).tickFormat(function (d) {
        return d + "%"
      });
      const g_yaxis = g.append('g').attr('class', 'y axis');

      //Update function to be retured
      function update(new_data, labels) {
        //console.log(new_data)
        xscale.domain(labels).padding(0.1);
        yscale.domain([100, 0]);


        g_xaxis.transition().attr("transform", "translate(0," + height + ")").call(xaxis);
        g_yaxis.transition().call(yaxis);

        posible_subgroups = [].concat.apply([],new_data).map((e) => e.game).filter((v,i,s) => s.indexOf(v) === i)
        let color = d3.scaleOrdinal().domain(posible_subgroups).range(posible_subgroups.map((v,i,s) => d3.color("hsl("+i/s.length*360+",70%,50%)")));
        //Get bars and add bars if require


        let bar_groups = g.selectAll(".bar_group").data(new_data);


        let bar_groups_enter = bar_groups.enter().append("g").attr("class", "bar_group");

        let bars = bar_groups.merge(bar_groups_enter).selectAll("rect").data((d) => d)

        let bar_enter = bars.enter().append("rect")
          .attr('x', (d) => xscale(d.label))
          .attr('y', 0)
          .attr('width', (d) => xscale.bandwidth(d.label))
          .attr('height', 0)
          .attr('class', (d) => 'bar_chart_bar_' + d.game)
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave)
          .on("click",mouseClick);

        //Set the correct values for all the bars

        bars.merge(bar_enter).transition()
          .attr('height', (d) => (height - yscale(d.val / d.total_sum * 100)))
          .attr("y", (d) => yscale(d.cum_sum / d.total_sum * 100))
          .attr('width', (d) => xscale.bandwidth(d.label))
          .attr('fill', (d) => color(d.game))
          .attr('hover-tooltip', (d) => d.game + " : " + d.val)
          .attr('data-genre',(d) => d.game)
          .attr('class', (d) => 'bar_chart_bar_' + d.game.replace(/\W/g, ''))
          .attr('x', (d) => xscale(d.label))

        //Remove unecesary bars
        bars.exit().remove();


      }
      return update
    }

    //This function creates setsup the bar chart by providing a update function
    function create_bar_chart(selector) {
      //Set the viewport and margins
      const viewport_width = 300;
      const viewport_height = 200;
      const margin = {
        top : 0,
        left : 50,
        bottom : 60,
        right : 50
      }


      const svg = d3.select(selector);
      let tooltipNode = document.createElement("div")
      document.querySelector(selector).parentNode.appendChild(tooltipNode)
      let tooltip = d3.select(tooltipNode)
      tooltip
        .style("opacity", 0)
        .attr("id", "stacked-tooltip")
        .style("background-color", "white")
        .style("postion","absolute")
        .style("border-radius", "5px")
        .style("border", "2px")
        .style("border-color","black")

      var mouseover = function (d) {
        tooltip
          .html("Value : " + d3.select(d.target).datum() )
          .style("opacity", 1)
        d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(0.5)");
      }
      var mousemove = function (d) {
        tooltip
        
        .style("transform","translateY(-55%)")  
          .style("left", d.pageX  +"px")
          .style("top", d.pageY - 20 + "px")
      }
      var mouseleave = function (d) {
        tooltip
          .style("opacity", 0)
          d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(1)");
      }

      var mouseClick = function (d) {
        cleanup_page();
        handle_submit(d.target.getAttribute("data-label"))
        d3.selectAll("." + d.target.getAttribute("class").split(" ")[0]).style("filter","brightness(1)");
      }

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width -  margin.left - margin.right;
      const height = viewport_height - margin.top - margin.bottom;

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left} , ${margin.top})`);


      //Create axes which fit our box exactly
      const xscale = d3.scaleBand().range([0, width]);
      const yscale = d3.scaleLinear().range([0, height]);

      const xaxis = d3.axisBottom().scale(xscale);
      const g_xaxis = g.append('g').attr('class', 'x axis');
      const yaxis = d3.axisLeft().scale(yscale).tickFormat(function (e) {
        if (Math.floor(e) != e) {
          return;
        }
        return e;
      });
      const g_yaxis = g.append('g').attr('class', 'y axis');

      //Update function to be retured
      function update(new_data, labels) {

        //Create the axis with the new data.
        xscale.domain(labels).padding(0.1);
        yscale.domain([d3.max(new_data), 0]);


        g_xaxis.transition().attr("transform", "translate(0," + height + ")").call(xaxis);
        g_xaxis.selectAll("text").attr("transform", "rotate(25)").style("text-anchor", "start");;
        g_yaxis.transition().call(yaxis);


        //Get bars and add bars if required
        const bars = g.selectAll("rect").data(new_data);

        const bar_enter = bars.enter().append("rect")
          .attr('x', (d) => xscale(labels[new_data.indexOf(d)]))
          .attr('y', height)
          .attr('width', xscale.bandwidth())
          .attr('height', 0)
          .attr('class', (d) => 'bar_chart_bar_' + labels[new_data.indexOf(d)].replace(/\W/g, '')  + " bar_chart_bar")
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave)
          .on("click",mouseClick);

        //Set the correct values for all the bars
        bars.merge(bar_enter).transition()
          .attr('height', (d) => (height - yscale(d)))
          .attr("y", (d) => (yscale(d)))
          .attr('width', xscale.bandwidth())
          .attr('x', (d) => xscale(labels[new_data.indexOf(d)]))
          .attr('class', (d) => 'bar_chart_bar_' + labels[new_data.indexOf(d)].replace(/\W/g, '')  + " bar_chart_bar")
          .attr("data-label", (d) => labels[new_data.indexOf(d)])
        //Remove unecesary bars
        bars.exit().remove();

      }
      return update;
    }


    function createPieChart(svgSelector, stateAttr, colorScheme) {
      const margin = 10;
      const radius = 100;

      // Creates sources <svg> element
      const svg = d3.select(svgSelector)
        .attr('width', radius * 2 + margin * 2)
        .attr('height', radius * 2 + margin * 2);

      // Group used to enforce margin
      const g = svg.append('g')
        .attr('transform', `translate(${radius + margin},${radius + margin})`);

      const pie = d3.pie().value((d) => d.values.length).sortValues(null).sort(null);
      const arc = d3.arc().outerRadius(radius).innerRadius(0);
      const noSlice = [{
          startAngle: 0,
          endAngle: Math.PI * 2,
          padAngle: 0
        },
        {
          startAngle: 0,
          endAngle: 0,
          padAngle: 0
        }
      ];

      const cscale = d3.scaleOrdinal(colorScheme);

      function update(new_data) { //{key: string, values: IPerson[]}[]
        const pied = pie(new_data);
        // Render the chart with new data

        cscale.domain(new_data.map((d) => d.key));

        // DATA JOIN
        const old = g.selectAll('path').data();

        function tweenArc(d, i) {
          const interpolate = d3.interpolateObject(old[i], d);
          return (t) => arc(interpolate(t));
        }

        // DATA JOIN
        const path = g.selectAll('path').data(pied, (d) => d.data.key).join(
          // ENTER
          // new elements
          (enter) => {
            const path_enter = enter.append('path')
              .attr('d', (d, i) => arc(noSlice[i]))
              .on('click', (event, d) => {
                if (state[stateAttr] === d.data.key) {
                  state[stateAttr] = null;
                } else {
                  state[stateAttr] = d.data.key;
                }
                updateApp();
              });
            path_enter.append('title');
            return path_enter;
          },
          (update) => update,
          (exit) => exit.transition()
          .attrTween('d', tweenArc)
          .remove()
        );

        // ENTER + UPDATE
        // both old and new elements
        path
          .classed('selected', (d) => d.data.key === state.selectedSex)
          .transition()
          .attrTween('d', tweenArc)
          .style('fill', (d) => cscale(d.data.key));

        path.select('title').text((d) => `${d.data.key}: ${d.data.values.length}`);
      }
      return update;
    }

    function handle_submit(option) {
      if (Object.keys(data[0]).includes(option)) {
        if (current_page_type != Page_type.Group) {
          cleanup_page();
        }
        document.getElementById("input_all").removeAttribute("error-tooltip");
        update_page_to_new_group(option);
        current_page_type = Page_type.Group;
      } else if (Object.keys(data[1]).includes(option)) {
        if (current_page_type != Page_type.Game) {
          cleanup_page();
        }
        document.getElementById("input_all").removeAttribute("error-tooltip");
        update_page_to_new_game(option);
        current_page_type = Page_type.Game;
      } else if (Object.keys(data[2]).includes(option)) {
        if (current_page_type != Page_type.Genre) {
          cleanup_page();
        }
        document.getElementById("input_all").removeAttribute("error-tooltip");
        update_page_to_new_genre(option);
        current_page_type = Page_type.Group;
      } else {
        document.getElementById("input_all").setAttribute("error-tooltip",
          "Please only select items fromt the list");
      }
    }

    function cleanup_page() {
      if (current_page_type == Page_type.Landing) {
        document.getElementById("stacked_bar_chart").setAttribute("style", "display:none;");
        document.getElementById("stacked_bar_chart").setAttribute("style", "display:none;");
      } else if (current_page_type == Page_type.Game) {
        document.getElementById("bar_chart_users").setAttribute("style", "display:none;");
      } else if (current_page_type == Page_type.Genre) {
        document.getElementById("bar_chart_users").setAttribute("style", "display:none;");
        document.getElementById("stacked_bar_chart").setAttribute("style", "display:none;");
      } else if (current_page_type == Page_type.Group) {
        document.getElementById("bar_chart_users").setAttribute("style", "display:none;");
      }

    }
  </script>
</head>

<body>
  <form id="input_all" onsubmit='handle_submit(document.getElementById("input_field").value)'>
    <input data-optgroup-list="search_options" id="input_field" type="select"></input>
    <datalist id="search_options">
      <optgroup id="search_options_genre" label="Genre"></optgroup>
      <optgroup id="search_options_country" label="Group"></optgroup>
      <optgroup id="search_options_games" label="Games"></optgroup>
    </datalist>
    <div class="list-options" id="list-options-search" hidden>
    </div>
    <input type="submit" value="Go">
  </form>

  <div id="main">
    <h1 id="page_header"></h1>
    <img id="banner">
    <p id="description"></p>

  </div>
  <div id="pie_chart" style="display: none;">
    <h3>Distribution actually playing</h3>
    <svg id="svg_pie" class="pie_chart_own_play"></svg>
  </div>
  <div id="bar_chart_users" style="display: none;">
    <h3 id="bar_chart_header">Number of user per group</h3>
    <svg id="svg_bar_chart_users" class="bar_chart bar_playing_time"></svg></div>
  <div id="stacked_bar_chart">
    <h3>Fraction of playtime for top N games by group</h3>
    N = <input type="number" min="1" max="10" value="5" id="stacked_bar_chart_N"><br>
    <svg id="svg_stacked_bar_chart"></svg>
  </div>
  <div id="">
  </div>

  <div>

  </div>
</body>

</html>