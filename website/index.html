<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="polyfill.css">
  <link rel="stylesheet" href="style.css">
  <script src="https://d3js.org/d3.v7.js"></script>
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <script>
    //This function adds poly fill to the searchbar adapted from https://codepen.io/jpdevries/pen/MoROzK
    function add_polyfill() {
      //Select all inputs which should be polyfilled and apply the things to it
      const lists = document.querySelectorAll('input[data-optgroup-list]');
      lists.forEach((list) => {
        const datalist = document.getElementById(list.getAttribute('data-optgroup-list'));
        const listOptions = document.getElementById("list-options-search");
        let optList = document.createElement("ul");
        listOptions.appendChild(optList);

        //Generate the polyfill list
        for (let optgroup of Array.from(datalist.childNodes)) {
          if (optgroup.nodeName == "#text") {
            continue
          }
          let details = optList.appendChild(document.createElement("li")).appendChild(document.createElement(
            "details"));
          details.setAttribute("open", "true");
          let groupName = document.createElement("summary");
          groupName.textContent = optgroup.getAttribute("label");


          details.appendChild(groupName);
          let optgroupUl = document.createElement("ul");
          for (let option of Array.from(optgroup.childNodes)) {
            if (optgroup.nodeName == "#text") {
              continue
            }
            let optionName = option.getAttribute("value");
            let optionLi = document.createElement("li")
            optionLi.setAttribute("class", "option");
            optionLi.setAttribute("data-value", optionName);

            let optionSpan = document.createElement("span");
            optionSpan.setAttribute("class", "value");
            optionSpan.textContent = optionName;

            optionLi.appendChild(optionSpan);
            optgroupUl.appendChild(optionLi);
          }
          details.appendChild(optgroupUl);
        }

        list.addEventListener('focus', (event) => {
          listOptions.removeAttribute('hidden');
        });


        list.addEventListener('blur', (event) => {
          //listOptions.setAttribute('hidden',"true");
        });

        list.addEventListener('input', (event) => {
          const {
            value
          } = event.target;

          const options = listOptions.querySelectorAll('.option');
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            const optionValue = option.querySelector('.value').innerHTML;

            const show = optionValue.includes(value);
            if (show) {
              option.removeAttribute('hidden');
            } else {
              option.setAttribute('hidden', 'true');
            }

          }

          const details = listOptions.querySelectorAll('details');
          details.forEach((detail) => {
            var allHidden = true;
            const options = detail.querySelectorAll('.option');
            for (let i = 0; i < options.length; i++) {
              const option = options[i];
              if (!option.hasAttribute('hidden')) {
                allHidden = false;
                break;
              }
            }
            if (allHidden) {
              detail.setAttribute('hidden', 'true');
            } else {
              detail.removeAttribute('hidden');
            }
          });

        }); // end input listener


        listOptions.addEventListener('click', (event) => {
          const el = (() => {
            if (!event.target.matches('.option')) { // one of the inner spans is dispatching the event
              return event.target.closest('.option');
            }
            return event.target;
          })();

          list.value = el.dataset.value;
          listOptions.setAttribute('hidden', 'true');
        });
      });
    };
    // Load data into the navigation bar
    const fetches = [
      fetch('../UserOwnedGames.json').then(response => response.json()),
      fetch('../GamesGenre.json').then(response => response.json()),
      fetch('../GenreData.json').then(response => response.json()),
      d3.csv('../RatingData.csv')
    ];


    data = [];
    groups = [];

    document.addEventListener("DOMContentLoaded", async () => {
      data = await Promise.all(fetches);
      groups = Object.keys(data[0])
      update_bar_chart = create_bar_chart("#svg_bar_chart")
      update_pie_chart_reviews = create_pie_chart("#svg_pie_review")
      update_pie_chart_play_own = create_pie_chart("#svg_pie_play_own")

      load_search_bar();
      createHeatMap("#datadiv");
    });

    function load_search_bar() {
      let option_list = d3.select("#search_options_country")
      for (const group of Object.keys(data[0]).sort()) {
        option_list.append("option").attr("value", group)
      }
      option_list = d3.select("#search_options_games")
      for (const game of Object.keys(data[1])) {
        option_list.append("option").attr("value", game)
      }
      option_list = d3.select("#search_options_genre")
      for (const genre of Object.keys(data[2])) {
        option_list.append("option").attr("value", genre)
      }

      add_polyfill();
      // set the submit action and prevent page from reloading
      var form = d3.select("#search").on('submit', (e) => e.preventDefault())
    }

    function update_page_to_new_group(group) {
      d3.select("#summary").attr("style", 'display:flex')
      d3.select("#page_header").html(group);
      d3.select("#banner").attr('src', '')
      d3.select("#game_text").attr('style', 'display:none')
      console.log("switched to new group")
      console.log(group)
    }

    function update_page_to_new_game(game) {
      game_id = data[1][game]['appid']
      link = "https://cdn.akamai.steamstatic.com/steam/apps/" + game_id + "/header.jpg"
      d3.select("#banner").attr('src', link)
      link_desc = "../GamesDescriptions.json"
      var desc = fetch(link_desc, {
          mode: 'cors'
        })
        .then(response => response.json())
        .then(function (result) {
          d3.select("#description").text(result[game_id])
        })
        .catch(error => console.log(error));

      var genres = data[1][game]["tags"]
      d3.select("#tags").selectAll("*").remove()
      var nr_genres = 0
      // d3.select("#tags").append("p")
      genres.forEach((genre) => {
        if (genre != "") {
          nr_genres += 1;
          d3.select("#tags").append("a")
            .attr("class", "app_tag")
            .text(genre)
            .on("click", function () {
              update_page_to_new_genre(genre)
            })
        }

      })
      if (nr_genres != 0) {
        d3.select("#tags").attr("style", "display:flex")
      } else {
        d3.select("#tags").attr("style", "display:none")

      }

      var price = data[1][game]["price"]
      if (price == null) {
        price = 0
      }
      d3.select("#price").text("Price:  " + price / 100)
      d3.select("#bar_chart").attr('style', 'display:block')

      update_bar_chart(data[1][game]["user_count"]);
      update_pie_chart_reviews(prepare_dict(data[1][game], ['positive_reviews', 'negative_reviews']))
      var user_cp = prepare_dict(data[1][game], ['user_count', 'user_played'])
      var ar = []
      ar[0] = {
        name: "Own and play",
        value: user_cp[1]["value"]
      }
      ar[1] = {
        name: "Own but never played",
        value: user_cp[0]["value"] - user_cp[1]["value"]
      }

      update_pie_chart_play_own(ar)
      d3.select("#page_header").html(game);
      document.getElementById("summary").setAttribute('style', 'display:flex')
      document.getElementById("game_text").setAttribute('style', 'display:block')

    }

    function prepare_dict(data, keys) {
      var ar = []
      for (const key of keys) {
        const dict = {}
        dict["name"] = key
        var val = data[key]
        if (Array.isArray(val)) {
          val = val.reduce((a, b) => a + b, 0)
        }
        dict["value"] = val
        ar.push(dict)
      }
      return ar
    }

    function update_page_to_new_genre(genre) {
      d3.select("#summary").attr("style", 'display:flex')
      d3.select("#page_header").html(genre);
      d3.select("#banner").attr('src', '')
      d3.select("#game_text").attr('style', 'display:none')
      console.log("switched to new genre")
      console.log(genre)

    }

    //This function creates setsup the bar chart by providing a update function
    function create_bar_chart(selector) {
      //Set the viewport and margins
      const viewport_width = 300;
      const viewport_height = 200;

      const margin_left = 30;
      const margin_top = 30;


      const svg = d3.select(selector);

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width - 2 * margin_left;
      const height = viewport_height - 2 * margin_top;

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', `translate(${margin_left} , ${margin_top})`);


      //Create axes which fit our box exactly
      const xscale = d3.scaleBand().range([0, width]);
      const yscale = d3.scaleLinear().range([0, height]);

      const xaxis = d3.axisBottom().scale(xscale);
      const g_xaxis = g.append('g').attr('class', 'x axis');
      const yaxis = d3.axisLeft().scale(yscale).tickFormat(function (e) {
        if (Math.floor(e) != e) {
          return;
        }

        return e;
      });
      const g_yaxis = g.append('g').attr('class', 'y axis');

      //Update function to be retured
      function update(new_data) {

        //Create the axis with the new data.
        xscale.domain(groups).padding(0.1);
        yscale.domain([d3.max(new_data), 0]);


        g_xaxis.transition().attr("transform", "translate(0," + height + ")").call(xaxis);
        g_yaxis.transition().call(yaxis);


        //Get bars and add bars if required
        const bars = g.selectAll("rect").data(new_data);

        const bar_enter = bars.enter().append("rect")
          .attr('x', (d) => xscale(groups[new_data.indexOf(d)]))
          .attr('y', height)
          .attr('width', xscale.bandwidth())
          .attr('height', 0);

        //Set the correct values for all the bars
        bars.merge(bar_enter).transition()
          .attr('height', (d) => (height - yscale(d)))
          .attr("y", (d) => (yscale(d)))
          .attr('width', xscale.bandwidth())
          .attr('x', (d) => xscale(groups[new_data.indexOf(d)]))

        //Remove unecesary bars
        bars.exit().remove();

      }
      return update;
    }

    function create_pie_chart(selector) {

      const viewport_width = 300;
      const viewport_height = 200;

      const margin_left = 30;
      const margin_top = 30;


      const svg = d3.select(selector);

      svg.attr("viewBox", `0 0 ${viewport_width} ${viewport_height}`);

      const width = viewport_width - 2 * margin_left;
      const height = viewport_height - 2 * margin_top;

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

      var color = d3.scaleOrdinal(d3.schemeSet3);

      var min = Math.min(width, height);
      var oRadius = min / 2 * 0.9;
      var iRadius = 0;

      // construct default pie
      var pie = d3.pie().value(function (d) {
        return d.value;
      }).sort(null);

      // construct arc generator
      var arc = d3.arc()
        .outerRadius(oRadius)
        .innerRadius(iRadius);


      function update(new_data) {

        const pied = pie(new_data)

        color.domain(new_data.map((d) => d.name))

        const old = g.selectAll('path').data();

        function tweenArc(d, i) {
          const interpolate = d3.interpolateObject(old[i], d);
          return (t) => arc(interpolate(t));
        }

        const path = g.selectAll('path').data(pied, (d) => d.data.name).join(
          (enter) => {
            const path_enter = enter.append('path')
            path_enter.append('title')
            return path_enter
          },
          (update) => update,
          (exit) => exit.transition()
          .attrTween('d', tweenArc)
          .remove()
        );

        path.transition()
          .attrTween('d', tweenArc)
          .style('fill', (d) => color(d.data.name))
        path.select('title').text((d) => d.data.name + ':' + d.data.value)

      }
      return update;
    }

    function createHeatMap(selector) {
      //Set the viewport and margins
      const margin_left = 120;
      const margin_top = 100;
      
      const viewport_width = document.getElementById("main").offsetWidth / 2;
      const viewport_height = document.getElementById("main").offsetHeight;


      const svg = d3.select(selector)
                    .append("svg")
                    .attr("width", viewport_width)
                    .attr("height", viewport_height)

      const width = viewport_width - 1.5* margin_left
      const height = viewport_height - 1.5* margin_top

      //Make the group element which contains the bars
      const g = svg.append('g')
        .attr('transform', `translate(${margin_left} , ${margin_top})`);

      //Read the data
      ratingData = data[3]
      var myPrice = []
      var myGenres = []
      // Labels of row and columns -> unique identifier of the column called 'price' and 'genre'
      ratingData.forEach((d) => {
        myPrice.push(d.price)
        myGenres.push(d.genre)
      })

      // Build X scales and axis:
      var x = d3.scaleBand()
        .range([0, width])
        .domain(myPrice)
        .padding(0.01);
      g.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x))

      // X axis label
      g.append("text")
        .attr("transform",
          "translate(" + (width / 2) + " ," +
          (height + margin_top / 2) + ")")
        .style("text-anchor", "middle")
        .text("Price");

      // Build Y scales and axis:
      var y = d3.scaleBand()
        .range([height, 0])
        .domain(myGenres)
        .padding(0.01);
      g.append("g")
        .call(d3.axisLeft(y));

      // Y axis label
      g.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin_left)
        .attr("x", 0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Value");

      // Build color scale
      var myColor = d3.scaleSequential()
        .interpolator(d3.interpolateSpectral)
        .domain([1, 100])

      let tooltipNode = document.createElement("div")
      document.querySelector(selector).parentNode.appendChild(tooltipNode)
      let tooltip = d3.select(tooltipNode)
      tooltip
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px")
        .style("display", "inline")
        .style("position", "fixed");

      // Three function that change the tooltip when user hover / move / leave a cell
      var mouseover = function (d) {
        tooltip
          .style("opacity", 0.9)
      }
      var mousemove = function (d) {
        let data = d3.select(d.target).datum()
        var pos_reviews = data.pos_reviews
        var count = data.count
        tooltip
          .html("Positive Reviews: " + ((pos_reviews < 1) ? 'N/A' : "<b>" + pos_reviews + "</b>%") +
            " | Games: <b>" + count + "</b>")
          .style("left", (d3.pointer(event)[0] + 40) + "px")
          .style("top", (d3.pointer(event)[1] + 40) + "px")
      }

      var mouseleave = function (d) {
        tooltip.style("opacity", 0)
      }

      // add the squares
      g.selectAll()
        .data(ratingData, function (d) {
          return d.price + ':' + d.genre;
        })
        .enter()
        .append("rect")
        .attr("x", function (d) {
          return x(d.price)
        })
        .attr("y", function (d) {
          return y(d.genre)
        })
        .attr("width", x.bandwidth())
        .attr("height", y.bandwidth())
        .style("fill", function (d) {
          return myColor((d.pos_reviews < 1) ? NaN : d.pos_reviews)
        }) //In order for empty entries to be black
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave)

      // Graph title
      g.append("text")
        .attr("x", 0)
        .attr("y", -40)
        .attr("text-anchor", "left")
        .style("font-size", "25px")
        .style("font-family", "arial")
        .text("Positive Reviews");

      // Graph subtitle
      g.append("text")
        .attr("x", 0)
        .attr("y", -15)
        .attr("text-anchor", "left")
        .style("font-size", "15px")
        .style("font-family", "arial")
        .style("fill", "grey")
        .style("max-width", width)
        .text("Percentage of positive reviews based on the game's genre and price");
    }


    function handle_submit() {
      let option = document.getElementById("input_field").value
      if (Object.keys(data[0]).includes(option)) {
        document.getElementById("search").removeAttribute("error-tooltip");
        update_page_to_new_group(option)

      } else if (Object.keys(data[1]).includes(option)) {
        document.getElementById("search").removeAttribute("error-tooltip");
        update_page_to_new_game(option);
      } else if (Object.keys(data[2]).includes(option)) {
        document.getElementById("search").removeAttribute("error-tooltip");
        update_page_to_new_genre(option)
      } else {
        console.log("NOT FOUND")
        document.getElementById("search").setAttribute("error-tooltip",
          "Please only select items fromt the list")
      }
    }
  </script>
</head>

<body style="background-color:#c7d5e0">
  <div class="wrap">
    <form class="search" id="search">
      <input data-optgroup-list="search_options" class="searchTerm" id="input_field" type="select"></input>
      <datalist id="search_options">
        <optgroup id="search_options_genre" label="Genre"></optgroup>
        <optgroup id="search_options_country" label="Group"></optgroup>
        <optgroup id="search_options_games" label="Games"></optgroup>
      </datalist>
      <div class="list-options" id="list-options-search" hidden>
      </div>
      <!-- <input type="text" class="searchTerm" placeholder="What are you looking for?"> -->
      <button type="submit" class="searchButton" id=searchButton onclick="handle_submit()">
        <i class="fa fa-search"></i>
      </button>
    </form>
  </div>
  <div class="main" id="main">
    <div id="summary">
      <div id="image"><img id="banner"></div>
      <div id="text">
        <h1 id="page_header"></h1>
        <div id="game_text">
          <p id="description"></p>
          <div id="tags">Genres:</div>
          <h3 id="price">Price: </h3>
        </div>
      </div>
    </div>
    <div class="charts">
      <div class="main-chart">
        <div id="datadiv"></div>
      </div>
      <div class="sub-charts">
      <div id="pie_chart_rev">
        <h3></h3><svg id="svg_pie_review" class="pie_chart review"></svg>
      </div>
      <div id="pie_chart_po"><svg id="svg_pie_play_own" class="pie_chart p_own"></svg></div>
      <div class="bar_chart" id="bar_chart" style="display: none;"><svg id="svg_bar_chart"
          class="bar_chart bar_playing_time"></svg></div>
    </div>
  </div>
  </div>
</body>

</html>